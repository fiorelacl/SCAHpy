# Tutorial 01: Salidas del modelo WRF

En este tutorial aprenderás a:

1. Leer un único archivo o múltiples archivos del modelo **WRF** usando SCAHpy.  
2. Realizar diagnósticos básicos como obtener la velocidad del viento y precipitación.  
3. Generar un mapa 2D y una serie de tiempo sencilla con variables meteorológicas.

Este flujo es ideal para comenzar a trabajar con las salidas de la componente
atmosférica del modelo acoplado *IGP RESM-COW* o de cualquier simulación WRF compatible.

## Lectura de un archivo WRF

En esta primera parte comenzaremos trabajando con *un solo archivo WRF*, lo cual permite comprender la estructura básica del dataset y el uso de las funciones principales. Más adelante extenderemos estos conceptos para el caso de *lecturas múltiples*.

### 1. Importación de paquetes

Importamos los módulos necesarios para el manejo de rutas, lectura de archivos WRF y operaciones numéricas:

```python
import scahpy as sc
import numpy as np
import glob
```

### 2. Definición del archivo WRF

Las funciones de lectura de SCAHpy requieren que las rutas de los archivos se proporcionen como *lista de strings*.
Existen dos formas de lograrlo:

**a) Colocar manualmente el archivo entre corchetes:**

```python
file_name = ['/data/users/fcastillon/wrf/wrfout_d01_2017-01-14_03:00:00']
```

**b) Utilizar `glob.glob`, que devuelve directamente una lista:**

```python
file_name = glob.glob('/data/users/fcastillon/wrf/wrfout_d01_2017-01-14_03:00:00')
```

Ambos métodos son equivalentes respecto al formato que necesita SCAHpy.

### 3. Selección de variables con `drop_vars`

Para optimizar la lectura, podemos indicar qué variables excluir del archivo WRF. 
Esto es especialmente útil en simulaciones pesadas o cuando se trabaja con múltiples archivos.

La función `drop_vars` tiene un punto importante:

> **Siempre requiere un único archivo (`file0`), en formato string, aun cuando trabajemos con múltiples archivos.**
> Esto se debe a que la función analiza la estructura y *metadata* típica del archivo WRF para identificar las variables que deben excluirse.

Por ello, incluso si `file_name` contiene más de un archivo, utilizamos:

```python
file_name[0]
```

En este ejemplo trabajaremos solo con cuatro variables: `LANDMASK`, `LAKEMASK`, `U10` y `V10`.

```python
vars_wrf = sc.drop_vars(
    file0 = file_name[0],
    sel_vars = ['LANDMASK', 'LAKEMASK', 'U10', 'V10'],
    model = 'WRF'
)
```

### 4. Lectura del archivo con `read_wrf`

A continuación, leemos el archivo usando la función `read_wrf`, pasando las opciones principales:

* **`drop_vars`**: variables a excluir (obtenidas previamente).
* **`dif_hours` y `sign`**: ajustes de huso horario (p. ej. Perú = UTC−5 → `dif_hours=5`, `sign=-1`).
* **`destag`**: si se requiere destaggering; en este ejemplo no es necesario.
* **`save_path`**: ruta opcional para guardar el archivo procesado.

```python
ds_wrf = sc.read_wrf(
    file_paths = file_name,
    drop_vars = vars_wrf,
    dif_hours = 5,
    sign = -1,
    destag = False,
    save_path = None
)
```

### 5. Cálculo de la velocidad del viento

A partir de los componentes horizontales `U10` y `V10`, calculamos la magnitud del viento superficial:

```python
ds_wrf['WSP'] = sc.wind_speed(ds_wrf.U10, ds_wrf.V10)
```

### 6. Mapa 2D: velocidad del viento con vectores

La función `map_1var_winds` pertenece al módulo: `scahpy.plots.maps`

Esta función permite graficar un campo escalar acompañado de un campo vectorial.
Los parámetros más relevantes que utilizamos aquí son:

* **`da`**: variable escalar a graficar (WSP).
* **`U`, `V`**: componentes del viento.
* **`levels`**: niveles del contorno.
* **`cmap`**: paleta de colores.
* **`quiver_subsample`**: frecuencia de muestreo para los vectores.
* **`quiverkey_speed`**: escala de referencia.
* **`time`**: tiempo a graficar.
* **`output_path`**: ruta para guardar la figura (si se desea).

Más detalles de cada parámetro, revisar la sección [Referencia de la API](04_API.qmd)

```python
sc.map_1var_winds(
    da = ds_wrf.WSP,
    U = ds_wrf.U10,
    V = ds_wrf.V10,
    levels = np.arange(0, 11, 1),
    cmap = 'rain',
    shapefile = None,
    extent = None,
    xticks = None,
    yticks = None,
    tick_step = (5, 5),
    draw_grid = False,
    time = '2017-01-14T13',
    month = None,
    quiver_subsample = 7,
    quiverkey_speed = 5.0,
    title = 'Velocidad del Viento',
    colorbar_label = 'm/s',
    output_path = None
)
```

![ds_maps](figs/fig_04.png){#fig-04 fig-align="center" width="75%"}

### 7. Aplicación de máscara para delimitar continente

Si deseamos graficar solo la zona **continental**, podemos usar `apply_mask`, que pertenece al módulo: `scahpy.core`

Una nota importante:

> Aunque `LANDMASK` distingue mar y tierra, el modelo WRF puede *interpolar incorrectamente variables sobre lagos*, como el Lago Titicaca.
> Por ello, es recomendable *excluir lagos* al trabajar con máscaras.

En este caso mantendremos únicamente superficie terrestre, por lo que usamos `sea_is_one = True` y `exclude_lakes = False`.
Se puede aplicar la máscara variable a variable (DataArray) o de manera grupal (Dataset)

> Ejemplo individual

```python
ds_wrf['WSP_land'] = sc.apply_mask(
    da = ds_wrf.WSP,
    mask = ds_wrf.LANDMASK,
    sea_is_one = True,
    lakemask = ds_wrf.LAKEMASK,
    exclude_lakes = False
)

ds_wrf['U10_land'] = sc.apply_mask(
    ds_wrf.U10,
    ds_wrf.LANDMASK,
    sea_is_one = True,
    lakemask = ds_wrf.LAKEMASK,
    exclude_lakes = False
)

ds_wrf['V10_land'] = sc.apply_mask(
    ds_wrf.V10,
    ds_wrf.LANDMASK,
    sea_is_one = True,
    lakemask = ds_wrf.LAKEMASK,
    exclude_lakes = False
)
```

> Ejemplo grupal

```python
ds_wrf = sc.apply_mask(
    da = ds_wrf,
    mask = ds_wrf.LANDMASK,
    vars = ['WSP','U10','V10'],
    sea_is_one = True,
    lakemask = ds_wrf.LAKEMASK,
    exclude_lakes = False
)
```

### 8. Nuevo mapa con la máscara aplicada

```python
sc.map_1var_winds(
    da = ds_wrf.WSP_land,
    U = ds_wrf.U10_land,
    V = ds_wrf.V10_land,
    levels = np.arange(0, 11, 1),
    cmap = 'rain',
    time = '2017-01-14T13',
    title = 'Velocidad del Viento',
    colorbar_label = 'm/s'
)
```

![ds_maps](figs/fig_05.png){#fig-05 fig-align="center" width="75%"}

## Lectura de múltiples archivos WRF

En esta sección extenderemos el procedimiento anterior para trabajar con **múltiples archivos WRF** correspondientes a una misma simulación. 

### 1. Importación de paquetes

Comenzamos importando los módulos necesarios:

```python
import scahpy as sc
import numpy as np
import glob
```

### 2. Listado de archivos WRF

Para leer múltiples archivos, utilizamos `glob.glob`, que retorna directamente una lista ordenada de rutas.
En este ejemplo filtramos todos los `wrfout` del año 2017:

```python
WRF_files = sorted(glob.glob("/data/users/fcastillon/wrf/wrfout_d01_2017*"))
```

> *Importante:* Aunque trabajemos con múltiples archivos, la función `drop_vars` siempre requiere un solo archivo (`file0`) para identificar la metadata genérica del WRF.
> Por ello, empleamos `WRF_files[0]`.

### 3. Selección de variables

Seleccionamos únicamente las variables necesarias para este ejemplo:

* `U10`, `V10`: viento a 10 m,
* `RAINC`, `RAINNC`: precipitación acumulada convectiva y de gran escala,
* `LANDMASK`, `LAKEMASK`: máscaras geográficas para filtrado posterior.

```python
vars_WRF = sc.drop_vars(
    WRF_files[0],
    sel_vars=['LAKEMASK', 'LANDMASK', 'U10', 'V10', 'RAINC', 'RAINNC']
)
```

### 4. Lectura de todos los archivos con `read_wrf`

Leemos todos los archivos al mismo tiempo. La función concatena automáticamente la dimensión temporal y ajusta coordenadas y metadatos.

```python
ds_WRF = sc.read_wrf(
    WRF_files,
    drop_vars = vars_WRF
)
```

### 5. Cálculo de la precipitación desacumulada

Las variables `RAINC` y `RAINNC` vienen **acumuladas** en el tiempo, por lo que utilizamos la función `precipitation` para obtener la precipitación total por paso temporal:

```python
ds_WRF['PP'] = sc.precipitation(
    ds_WRF["RAINC"],
    ds_WRF["RAINNC"],
    name = 'PP',
    units = 'mm'
)
```

### 6. Aplicación de máscara: solo océano

En este caso conservaremos únicamente los valores sobre *océano*, por lo que utilizamos:

* `sea_is_one = False` (la tierra es 1, el océano 0 en LANDMASK),
* `exclude_lakes = True` para evitar efectos de interpolación sobre lagos (p. ej., el Titicaca), donde WRF a veces genera valores no deseados.

```python
ds_WRF['U10_land'] = sc.apply_mask(
    ds_WRF.U10,
    ds_WRF.LANDMASK,
    sea_is_one = False,
    lakemask = ds_WRF.LAKEMASK,
    exclude_lakes = True
)

ds_WRF['V10_land'] = sc.apply_mask(
    ds_WRF.V10,
    ds_WRF.LANDMASK,
    sea_is_one = False,
    lakemask = ds_WRF.LAKEMASK,
    exclude_lakes = True
)
```

### 7. Agregación mensual

Utilizamos la función `aggregate_dmy` (del módulo `core.time_ops`) para calcular:

* Acumulado mensual de precipitación (`accum=['PP']`),
* Promedio mensual del viento a 10 m (`avg=['U10_land','V10_land']`).

```python
ds_WRF_m = sc.aggregate_dmy(
    ds = ds_WRF[['PP','U10_land','V10_land']],
    tiempo = 'ME',
    accum = ['PP'],
    avg = ['U10_land','V10_land'],
    mediana = None
)
```

### 8. Mapa mensual: precipitación acumulada + viento

Finalmente, generamos un mapa mensual utilizando la función `map_1var_winds` del módulo: `scahpy.plots.maps`

Representamos la precipitación acumulada del mes y los vientos promedio (solo en superficie):

```python
sc.map_1var_winds(
    da = ds_WRF_m.PP,
    U = ds_WRF_m.U10_land,
    V = ds_WRF_m.V10_land,
    levels = np.arange(0, 500, 10),
    cmap = 'rain',
    shapefile = None,
    extent = None,
    xticks = None,
    yticks = None,
    tick_step = (5, 5),
    draw_grid = False,
    time = '2017-03',
    month = None,
    quiver_subsample = 7,
    quiverkey_speed = 5.0,
    title = 'Precipitation + Winds at 10m',
    colorbar_label = 'm/s',
    output_path = None
)
```
![ds_maps](figs/fig_06.png){#fig-06 fig-align="center" width="75%"}


## Nota sobre uso de memoria y rendimiento

Al trabajar con salidas WRF, especialmente cuando se leen *múltiples archivos*, es importante considerar el uso de memoria y el tipo de cálculos que se realizan. SCAHpy se apoya en `xarray` + `dask`, por lo que muchas operaciones se ejecutan de forma *perezosa* (lazy) hasta que se llama explícitamente a métodos como `.compute()` o `.persist()`.

A continuación se presentan algunas recomendaciones prácticas:

#### ¿Cuántos archivos leer de golpe?

No existe un número único, ya que depende de:

* Tamaño de cada archivo WRF (número de niveles, variables, resolución espacial).
* Cantidad de memoria RAM disponible.
* Número de variables efectivamente cargadas (controlado con `drop_vars`).

Como regla general:

* En un entorno de escritorio con memoria limitada, es más seguro:

  * *Leer por bloques de tiempo* (por ejemplo, uno o varios meses) en lugar de todo un período de varios años.
  * Reducir el número de variables usando `drop_vars` antes de cualquier diagnóstico pesado.
* En un clúster o servidor con mayor memoria:

  * Es razonable leer un año completo de simulación siempre que:

    * Se trabaje con pocas variables clave.
    * Se mantenga el procesamiento de forma perezosa (sin hacer `.compute()` sobre todo el dominio a cada paso).

Si al ejecutar una operación el sistema empieza a usar *swap* o se vuelve muy lento, es un indicio de que conviene *dividir el problema en menos archivos o menor rango temporal*.

#### ¿Cuándo usar `.compute()`?

Usa `.compute()` cuando:

* Ya has definido toda la cadena de operaciones y necesitas el resultado completo en memoria para:

  * Graficar una figura concreta.
  * Guardar un producto final relativamente pequeño (por ejemplo, un promedio mensual o climatología ya reducida en el tiempo).
  * Inspeccionar numéricamente una variable (por ejemplo, `ds.isel(time=0).PP.values`).

En general:

* Evita hacer `.compute()` sobre datasets muy grandes en etapas intermedias.
* Prefiere:

  * Reducir primero dimensiones (e.g. promedios temporales, recortes espaciales).
  * Luego aplicar `.compute()` sobre el resultado ya “resumido”.

#### ¿Cuándo usar `.persist()`?

`.persist()` es útil cuando:

* Has realizado un preprocesamiento costoso (por ejemplo, cálculo de varias variables diagnósticas, máscaras, cambio de calendario) que piensas reutilizar varias veces.
* Quieres mantener el dataset *en memoria distribuida* (en RAM) sin traer todo como `numpy`, pero sí evitando repetir los mismos cálculos una y otra vez.

Ejemplo típico:

```python
ds_proc = ds_WRF[['PP', 'U10_land', 'V10_land']].persist()
```

A partir de `ds_proc`, puedes:

* Calcular distintos agregados temporales (`aggregate_dmy`, promedios estacionales, etc.).
* Generar varias figuras sin recalcular toda la cadena de operaciones inicial.

No es necesario usar `.persist()` si el cálculo es pequeño o si solo lo harás una vez; en esos casos, `.compute()` al final suele ser suficiente.

#### Recomendaciones adicionales

* **Filtra pronto y filtra fuerte**:

  * Usa `drop_vars` al inicio para reducir la cantidad de variables.
  * Recorta la región de interés (`.sel(lat=..., lon=...)`) antes de operaciones costosas.
* **Cuidado con los bucles explícitos en Python**:

  * Siempre que sea posible, deja que `xarray`/`dask` manejen los bucles ocultos sobre el tiempo o sobre otras dimensiones.
* **Prueba con un subconjunto**:

  * Antes de procesar todo el año, prueba con 2–3 archivos para verificar que:

    * El flujo de trabajo funciona.
    * El consumo de memoria es razonable.
