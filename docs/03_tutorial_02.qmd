# Tutorial 02: Salidas del modelo CROCO

En este tutorial aprenderás a:

1. Leer un único archivo o múltiples archivos del modelo **CROCO** usando SCAHpy.  
2. Realizar diagnósticos básicos como obtener el gradiente de SST en superficie.  
3. Generar un mapa 2D, hovmoller y una serie de tiempo sencilla con variables oceanográficas.

Este flujo es ideal para comenzar a trabajar con las salidas de la componente
oceánica del modelo acoplado *IGP RESM-COW* o de cualquier simulación CROCO compatible.

## Lectura de un archivo CROCO

En esta primera parte comenzaremos trabajando con *un solo archivo CROCO*, lo cual permite comprender la estructura básica del dataset y el uso de las funciones principales. Más adelante extenderemos estos conceptos para el caso de *lecturas múltiples*.

### 1. Importación de paquetes

Importamos los módulos necesarios para el manejo de rutas, lectura de archivos CROCO y operaciones numéricas:

Como en el tutorial anterior, importamos los módulos necesarios:

```python
import scahpy as sc
import numpy as np
import glob
import xarray as xr
```
### 2. Definición del archivo CROCO

Las funciones de lectura de SCAHpy requieren que las rutas de los archivos se proporcionen como *lista de strings*.
Existen dos formas de lograrlo:

**a) Colocar manualmente el archivo entre corchetes:**

```python
file_name = ['/data/users/fcastillon/croco/croco_avg_Y2017M01.nc']
```

**b) Utilizar `glob.glob`, que devuelve directamente una lista:**

```python
file_name = glob.glob('/data/users/fcastillon/croco/croco_avg_Y2017M01.nc')
```

Ambos métodos son equivalentes respecto al formato que necesita SCAHpy.

### 3. Selección de variables con `drop_vars`

Para optimizar la lectura, podemos indicar qué variables excluir del archivo CROCO. 
Esto es especialmente útil en simulaciones pesadas o cuando se trabaja con múltiples archivos.

La función `drop_vars` tiene un punto importante:

> **Siempre requiere un único archivo (`file0`), en formato string, aun cuando trabajemos con múltiples archivos.**
> Esto se debe a que la función analiza la estructura y *metadata* típica del archivo CROCO para identificar las variables que deben excluirse.

Por ello, incluso si `file_name` contiene más de un archivo, utilizamos:

```python
file_name[0]
```

En este ejemplo trabajaremos solo con cuatro variables: `mask_rho`, `temp`, `u` y `v`.

```python
vars_croco = sc.drop_vars(file_name[0],
                          sel_vars = ['temp','mask_rho','u','v'],
                          model = 'CROCO')
```

### 4. Lectura del archivo con `read_croco`

A continuación, leemos el archivo usando la función `read_croco`, pasando las opciones principales:

* **`drop_vars`**: variables a excluir (obtenidas previamente).
* **`destag`**: si se requiere destaggering; en este ejemplo sí es necesario por los vectores de viento u y v.
* **`save_path`**: ruta opcional para guardar el archivo procesado.

```python
ds_croco = sc.read_croco(file_paths = file_name,
                         drop_vars = vars_croco,
                         destag = True,
                         save_path = None)
```
### 5. Aplicación de máscara para delimitar continente

Si deseamos graficar solo la zona **oceánica**, podemos usar `apply_mask`, que pertenece al módulo: `scahpy.core`

En este caso mantendremos únicamente el océano, por lo que usamos `sea_is_one = True` y pasamos la variable que tiene la máscara que es `mask_rho`

```python
ds_croco_mask = sc.apply_mask(da = ds_croco[['temp','u','v']],
                              mask = ds_croco.mask_rho,
                              sea_is_one = True).isel(levels=-1)
```

### 6. Mapa 2D: SST con vectores del viento
Como las variables son a distintos niveles verticales, al hacer `.isel(levels=-1)` seleccionamos el nivel más cercano a la superficie.

* **`da`**: variable escalar a graficar (temp).
* **`U`, `V`**: componentes del viento.
* **`levels`**: niveles del contorno.
* **`cmap`**: paleta de colores.
* **`quiver_subsample`**: frecuencia de muestreo para los vectores.
* **`quiverkey_speed`**: escala de referencia.
* **`time`**: tiempo a graficar.
* **`output_path`**: ruta para guardar la figura (si se desea).

```python
sc.map_1var_winds(da = ds_croco_mask.temp,
                  U = ds_croco_mask.u,
                  V = ds_croco_mask.v,
                  time = '2017-01-14',
                  cmap = 'jet',
                  levels = np.arange(18,30,1),
                  quiverkey_speed = 1,
                  title = 'Sea Surface Temperature',
                  colorbar_label = '°C')
```
![ds_maps](figs/fig_07.png){#fig-07 fig-align="center" width="75%"}

Más detalles de cada parámetro, revisar la sección [Referencia de la API](04_API.qmd).

### 7. Serie de Tiempo 

```python
sc.ts_area_1var(da = ds_croco_mask.temp,
    lat_range = (-10,0),
    lon_range  = (-90,-80),
    label  = 'IGP RESM-COW',
    color = '#1b9e77',
    linestyle  = '-',
    linewidth  = 1.8,
    title  = 'Time Series at Niño 1+2',
    ylabel  = 'SST °C')
```
![ds_maps](figs/fig_08.png){#fig-08 fig-align="center" width="75%"}

## Lectura de múltiples archivos CROCO

En esta sección ampliaremos el flujo de trabajo para procesar *múltiples archivos CROCO* provenientes de una misma simulación. El objetivo es leer todos los archivos del año 2017, aplicar una máscara oceánica, generar diagnósticos básicos (como energía cinética superficial), realizar inspecciones rápidas de series temporales y finalmente aplicar interpolación vertical desde coordenadas sigma hacia niveles en metros.

### 1. Importación de paquetes

Comenzamos importando los módulos necesarios:

```python
import scahpy as sc
import numpy as np
import glob
import xarray as xr
```

### 2. Listado de archivos CROCO

Listamos de forma ordenada todos los archivos `croco_avg` correspondientes al año 2017:

```python
CROCO_files = sorted(glob.glob("/data/users/fcastillon/COW_outs/diagnos/C2O5W4_SF2/croco/croco_avg_Y2017*.nc"))
```
### 3. Selección de variables

Al igual que en el caso WRF, la función `drop_vars` requiere *un solo archivo*, incluso cuando trabajamos con múltiples, para obtener la metadata genérica del NetCDF.
En este ejemplo seleccionaremos únicamente:

* `temp` → temperatura
* `u`, `v` → componentes de velocidad oceánica
* `mask_rho` → máscara para rejilla rho

```python
vars_croco = sc.drop_vars(
    CROCO_files[0],
    sel_vars = ['temp', 'mask_rho', 'u', 'v'],
    model = 'CROCO'
)
```

### 4. Lectura de todos los archivos CROCO

Leemos todos los archivos del listado. SCAHpy concatena automáticamente la dimensión temporal y normaliza las coordenadas espaciales:

```python
ds_croco = sc.read_croco(CROCO_files, drop_vars=vars_croco)
```

### 5. Aplicación de máscara oceánica

Aplicamos la máscara `mask_rho` para conservar únicamente valores en *océano* para estas 3 variables: `temp`, `u` y `v`.

```python
ds_croco = sc.apply_mask(
    ds_croco,
    var_names=['temp', 'u', 'v'],
    mask=ds_croco.mask_rho,
    sea_is_one=True
)
```

### 6. Diagnóstico de energía cinética superficial

Se calcula la energía cinética en superficie a partir de las componentes horizontales.
Como previamente ya se aplicó la máscara oceánica, no es necesario pasar el parámetro `mask` a la función:

```python
ds_croco['ke_sfc'] = sc.ke_sfc(
    u=ds_croco.u,
    v=ds_croco.v
)
```

### 7. Inspección rápida: serie temporal en un punto

Podemos visualizar la serie temporal en un punto específico (latitud −5°, longitud −85°) con la función `ts_point_1var`.
Seleccionamos el nivel superficial (`levels = -1`):

```python
sc.ts_point_1var(
    da = ds_croco.ke_sfc.isel(levels=-1),
    lat = -5,
    lon = -85
)
```
![ds_maps](figs/fig_09.png){#fig-09 fig-align="center" width="75%"}

### 8. Agregación diaria → mensual

Usamos `aggregate_dmy` para generar promedios mensuales de `temp`, `u` y `v`.
Agregamos `.load()` para materializar los resultados en memoria, lo cual es apropiado cuando posteriormente deseamos guardar el dataset o graficar varias veces los mismos valores.

> **¿Está bien usar `.load()` aquí?**
> Sí. Dado que el dataset mensual es mucho más pequeño que el diario y que planeamos reutilizarlo para series de tiempo, es adecuado cargarlo completamente.

```python
ds_croco_m = sc.aggregate_dmy( ds = ds_croco,
                               tiempo = 'ME',
                               accum = None,
                               avg = ['u', 'v', 'temp'],
                               mediana = None).load()
```

### 9. Serie temporal en un área oceánica

Con los datos mensuales ya agregados, graficamos una serie temporal conjunta de `u` y `v` en la región comprendida entre:

* latitudes: −10° a 0°
* longitudes: −90° a −80°

```python
sc.ts_area_multi( series = [{"da": ds_croco_m.u.isel(levels=-1), "label": 'u at sfc', "color": 'red', "linestyle": '--', "linewidth": 1.5},
                            {"da": ds_croco_m.v.isel(levels=-1), "label": 'v at sfc', "color": 'blue', "linestyle": '-', "linewidth": 1.5},],
                  lat_range = (-10, 0),
                  lon_range = (-90, -80))
```
![ds_maps](figs/fig_10.png){#fig-10 fig-align="center" width="75%"}


### 10. Preparación para la interpolación sigma–z

Para realizar la interpolación vertical es recomendable *cargar los datos en memoria*:

```python
ds_croco = ds_croco.load()
```

### 11. Interpolación sigma → niveles en metros

Utilizamos la función `crocointerp_sigma_to_z` para obtener perfiles verticales desde −200 m hasta la superficie cada 20 m.

#### a) Interpolación estándar (con `nan` donde no hay datos)

```python
ds_croco_int = sc.crocointerp_sigma_to_z(
    ds = ds_croco,
    var_names = ['temp'],
    z_levels = np.arange(-200, 20, 20),
    z_units = 'm',
    sigma_dim = 'levels',
    new_dim = 'z',
    mask_outside = False
)
```

#### b) Interpolación extrapolada (`nan_opt='none'`)

Esta opción evita valores `nan` rellenando mediante extrapolación:

```python
ds_croco_int2 = sc.crocointerp_sigma_to_z(
    ds = ds_croco,
    var_names = ['temp'],
    z_levels = np.arange(-200, 20, 20),
    z_units = 'm',
    sigma_dim = 'levels',
    new_dim = 'z',
    mask_outside = False,
    nan_opt = 'none'
)
```

### 12. Secciones verticales sigma–z

Finalmente, generamos cortes verticales a lo largo de la latitud −5°, comparando interpolación estándar vs. extrapolada:

```python
sc.section_xz_1var(
    ds_croco_int.temp.sel(lon=slice(-95, -78)),
    lat = -5,
    levels = np.arange(0, 25, 1),
    cmap = 'jet',
    time = '2017-01-01',
    yinv = False
)

sc.section_xz_1var(
    ds_croco_int2.temp.sel(lon=slice(-95, -78)),
    lat = -5,
    levels = np.arange(0, 25, 1),
    cmap = 'jet',
    time = '2017-01-01',
    yinv = False
)
```
::: {#fig-d1 layout-ncol=2}

![nan_opt='both'](figs/fig_11.png){#fig-11 fig-align="center" width="75%"}

![nan_opt='none'](figs/fig_12.png){#fig-12 fig-align="center" width="75%"}

Sección Vertical
:::
